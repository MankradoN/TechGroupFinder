{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport URLManager from \"./URLManager\";\nimport RequestSequencer from \"./RequestSequencer\";\nimport DebounceManager from \"./DebounceManager\";\nimport * as actions from \"./actions\";\nimport Events from \"./Events\";\nimport { mergeFilters } from \"./helpers\";\nimport { INVALID_CREDENTIALS } from \".\";\nimport * as a11y from \"./A11yNotifications\";\n\nfunction filterSearchParameters(_ref) {\n  let {\n    current,\n    filters,\n    resultsPerPage,\n    searchTerm,\n    sortDirection,\n    sortField,\n    sortList\n  } = _ref;\n  return {\n    current,\n    filters,\n    resultsPerPage,\n    searchTerm,\n    sortDirection,\n    sortField,\n    sortList\n  };\n}\n\nexport const DEFAULT_STATE = {\n  // Search Parameters -- This is state that represents the input state.\n  current: 1,\n  filters: [],\n  resultsPerPage: 20,\n  searchTerm: \"\",\n  sortDirection: \"\",\n  sortField: \"\",\n  sortList: [],\n  // Result State -- This state represents state that is updated automatically\n  // as the result of changing input state.\n  autocompletedResults: [],\n  autocompletedResultsRequestId: \"\",\n  autocompletedSuggestions: {},\n  autocompletedSuggestionsRequestId: \"\",\n  error: \"\",\n  isLoading: false,\n  facets: {},\n  requestId: \"\",\n  results: [],\n  resultSearchTerm: \"\",\n  totalPages: 0,\n  totalResults: 0,\n  pagingStart: 0,\n  pagingEnd: 0,\n  wasSearched: false,\n  rawResponse: {}\n};\n\nfunction removeConditionalFacets() {\n  let facets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let conditionalFacets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let filters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return Object.entries(facets).reduce((acc, _ref2) => {\n    let [facetKey, facet] = _ref2;\n\n    if (conditionalFacets[facetKey] && typeof conditionalFacets[facetKey] === \"function\" && !conditionalFacets[facetKey]({\n      filters\n    })) {\n      return acc;\n    }\n\n    acc[facetKey] = facet;\n    return acc;\n  }, {});\n}\n/*\n * The Driver is a framework agnostic search state manager that is capable\n * syncing state to the url.\n */\n\n\nclass SearchDriver {\n  constructor(_ref3) {\n    var _this = this;\n\n    let {\n      apiConnector,\n      autocompleteQuery = {},\n      debug,\n      initialState,\n      onSearch,\n      onAutocomplete,\n      onResultClick,\n      onAutocompleteResultClick,\n      searchQuery = {},\n      trackUrlState = true,\n      urlPushDebounceLength = 500,\n      hasA11yNotifications = false,\n      a11yNotificationMessages = {},\n      alwaysSearchOnInitialLoad = false\n    } = _ref3;\n    this.state = DEFAULT_STATE;\n    /**\n     * This method is used to update state and trigger a new autocomplete search.\n     *\n     * @param {string} searchTerm\n     * @param {Object=} Object\n     * @param {boolean|Object} options.autocompleteResults - Should autocomplete results\n     * @param {boolean|Object} options.autocompleteSuggestions - Should autocomplete suggestions\n     */\n\n    this._updateAutocomplete = function (searchTerm) {\n      let {\n        autocompleteResults,\n        autocompleteSuggestions\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      const requestId = _this.autocompleteRequestSequencer.next();\n\n      const queryConfig = Object.assign(Object.assign({}, autocompleteResults && {\n        results: _this.autocompleteQuery.results || {}\n      }), autocompleteSuggestions && {\n        suggestions: _this.autocompleteQuery.suggestions || {}\n      });\n      return _this.events.autocomplete({\n        searchTerm\n      }, queryConfig).then(autocompleted => {\n        if (_this.autocompleteRequestSequencer.isOldRequest(requestId)) return;\n\n        _this.autocompleteRequestSequencer.completed(requestId);\n\n        _this._setState(autocompleted);\n      });\n    };\n    /**\n     * This method is used to update state and trigger a new search.\n     *\n     * @typedef {Object} RequestState\n     * @property {number} current\n     * @property {number} resultsPerPage\n     * @property {string} searchTerm\n     * @property {string} sortDirection\n     * @property {string} sortField\n     * @property {Array} sortList\n     *\n     * @param {RequestState} searchParameters - RequestState\n     * @param {Object=} Object\n     * @param {boolean} options.skipPushToUrl - Skip pushing the updated to the URL\n     * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n     * rather than 'push' to avoid adding a new history entry\n     */\n\n\n    this._updateSearchResults = function (searchParameters) {\n      let {\n        skipPushToUrl = false,\n        replaceUrl = false\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        current,\n        filters,\n        resultsPerPage,\n        searchTerm,\n        sortDirection,\n        sortField,\n        sortList\n      } = Object.assign(Object.assign({}, _this.state), searchParameters); // State updates should always be applied in the order that they are made. This function, _updateSearchResults,\n      // makes state updates.\n      // In the case where a call to \"_updateSearchResults\" was made and delayed for X amount of time using\n      // `debounceManager.runWithDebounce`, and a subsequent call is made _updateSearchResults before that delay ends, we\n      // want to make sure that outstanding call to \"_updateSearchResults\" is cancelled, as it would apply state updates\n      // out of order.\n\n      _this.debounceManager.cancelByName(\"_updateSearchResults\");\n\n      _this._setState({\n        current,\n        error: \"\",\n        filters,\n        resultsPerPage,\n        searchTerm,\n        sortDirection,\n        sortField,\n        sortList\n      });\n\n      _this._makeSearchRequest({\n        skipPushToUrl,\n        replaceUrl\n      });\n    };\n    /**\n     * This method is separated out from _updateSearchResults so that it\n     * can be debounced.\n     *\n     * By debouncing our API calls, we can effectively allow action chaining.\n     *\n     * For Ex:\n     *\n     * If a user needs to make multiple filter updates at once, they could\n     * do so by calling an action 3 times in a row:\n     *\n     *   addFilter(\"states\", \"California\");\n     *   addFilter(\"states\", \"Nebraska\");\n     *   addFilter(\"states\", \"Pennsylvania\");\n     *\n     * We don't want to make 3 separate API calls like that in quick succession,\n     * so we debounce the API calls.\n     *\n     * Application state updates are performed in _updateSearchResults, but we\n     * wait to make the actual API calls until all actions have been called.\n     *\n     * @param {Object} options\n     * @param {boolean} options.skipPushToUrl - Skip pushing the updated to the URL\n     * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n     * rather than 'push' to avoid adding a new history entry\n     */\n\n\n    this._makeSearchRequest = DebounceManager.debounce(0, _ref4 => {\n      let {\n        skipPushToUrl,\n        replaceUrl\n      } = _ref4;\n      const {\n        current,\n        filters,\n        resultsPerPage,\n        searchTerm,\n        sortDirection,\n        sortField,\n        sortList\n      } = this.state;\n\n      this._setState({\n        isLoading: true\n      });\n\n      const requestId = this.searchRequestSequencer.next();\n\n      const _a = this.searchQuery,\n            {\n        conditionalFacets\n      } = _a,\n            restOfSearchQuery = __rest(_a, [\"conditionalFacets\"]);\n\n      const queryConfig = Object.assign(Object.assign({}, restOfSearchQuery), {\n        facets: removeConditionalFacets(this.searchQuery.facets, conditionalFacets, filters)\n      });\n      const requestState = Object.assign(Object.assign({}, filterSearchParameters(this.state)), {\n        filters: mergeFilters(filters, this.searchQuery.filters)\n      });\n      return this.events.search(requestState, queryConfig).then(resultState => {\n        if (this.searchRequestSequencer.isOldRequest(requestId)) return;\n        this.searchRequestSequencer.completed(requestId); // Results paging start & end\n\n        const {\n          totalResults\n        } = resultState;\n        const start = totalResults === 0 ? 0 : (current - 1) * resultsPerPage + 1;\n        const end = totalResults < start + resultsPerPage ? totalResults : start + resultsPerPage - 1;\n\n        this._setState(Object.assign(Object.assign({\n          isLoading: false,\n          resultSearchTerm: searchTerm,\n          pagingStart: start,\n          pagingEnd: end\n        }, resultState), {\n          wasSearched: true\n        }));\n\n        if (this.hasA11yNotifications) {\n          const messageArgs = {\n            start,\n            end,\n            totalResults,\n            searchTerm\n          };\n          this.actions.a11yNotify(\"searchResults\", messageArgs);\n        }\n\n        if (!skipPushToUrl && this.trackUrlState) {\n          // We debounce here so that we don't get a lot of intermediary\n          // URL state if someone is updating a UI really fast, like typing\n          // in a live search box for instance.\n          this.debounceManager.runWithDebounce(this.urlPushDebounceLength, \"pushStateToURL\", this.URLManager.pushStateToURL.bind(this.URLManager), {\n            current,\n            filters,\n            resultsPerPage,\n            searchTerm,\n            sortDirection,\n            sortField,\n            sortList\n          }, {\n            replaceUrl\n          });\n        }\n      }, error => {\n        var _a;\n\n        if (error.message === INVALID_CREDENTIALS) {\n          // The connector should have invalidated the credentials in its state by now\n          // Getting the latest state from the connector\n          this._setState(Object.assign({}, ((_a = this.apiConnector) === null || _a === void 0 ? void 0 : _a.state) && Object.assign({}, this.apiConnector.state))); // Stop execution of request\n          // and let the consuming application handle the missing credentials\n\n\n          return;\n        }\n\n        this._setState({\n          error: `An unexpected error occurred: ${error.message}`\n        });\n      });\n    });\n    this.actions = Object.entries(actions).reduce((acc, _ref5) => {\n      let [actionName, action] = _ref5;\n      return Object.assign(Object.assign({}, acc), {\n        [actionName]: action.bind(this)\n      });\n    }, {});\n    this.actions = Object.assign(Object.assign({}, this.actions), (apiConnector === null || apiConnector === void 0 ? void 0 : apiConnector.actions) && Object.assign({}, apiConnector.actions));\n    Object.assign(this, this.actions);\n    this.events = new Events({\n      apiConnector,\n      onSearch,\n      onAutocomplete,\n      onResultClick,\n      onAutocompleteResultClick\n    });\n    this.debug = debug;\n\n    if (this.debug) {\n      console.warn(\"Search UI Debugging is enabled. This should be turned off in production deployments.\");\n      if (typeof window !== \"undefined\") window[\"searchUI\"] = this;\n    }\n\n    this.autocompleteRequestSequencer = new RequestSequencer();\n    this.searchRequestSequencer = new RequestSequencer();\n    this.debounceManager = new DebounceManager();\n    this.autocompleteQuery = autocompleteQuery;\n    this.searchQuery = searchQuery;\n    this.subscriptions = [];\n    this.trackUrlState = trackUrlState;\n    this.urlPushDebounceLength = urlPushDebounceLength;\n    this.alwaysSearchOnInitialLoad = alwaysSearchOnInitialLoad;\n    this.apiConnector = apiConnector;\n    let urlState;\n\n    if (trackUrlState) {\n      this.URLManager = new URLManager();\n      urlState = this.URLManager.getStateFromURL();\n      this.URLManager.onURLStateChange(urlState => {\n        this._updateSearchResults(Object.assign(Object.assign({}, DEFAULT_STATE), urlState), {\n          skipPushToUrl: true\n        });\n      });\n    } else {\n      urlState = {};\n    } // Manage screen reader accessible notifications\n\n\n    this.hasA11yNotifications = hasA11yNotifications;\n    if (this.hasA11yNotifications) a11y.getLiveRegion();\n    this.a11yNotificationMessages = Object.assign(Object.assign({}, a11y.defaultMessages), a11yNotificationMessages); // Remember the state this application is initialized into, so that we can\n    // reset to it later.\n\n    this.startingState = Object.assign(Object.assign({}, this.state), initialState); // We filter these here to disallow anything other than valid search\n    // parameters to be passed in initial state, or url state. `results`, etc,\n    // should not be allowed to be passed in, that should be generated based on\n    // the results of the query\n\n    const searchParameters = filterSearchParameters(Object.assign(Object.assign({}, this.startingState), urlState)); // Initialize the state without calling _setState, because we don't\n    // want to trigger an update callback, we're just initializing the state\n    // to the correct default values for the initial UI render\n\n    this.state = Object.assign(Object.assign(Object.assign({}, this.state), (apiConnector === null || apiConnector === void 0 ? void 0 : apiConnector.state) && Object.assign({}, apiConnector.state)), searchParameters); // We'll trigger an initial search if initial parameters contain\n    // a search term or filters, or if alwaysSearchOnInitialLoad is set.\n    // Otherwise, we'll just save their selections in state as initial values.\n\n    if (searchParameters.searchTerm || searchParameters.filters.length > 0 || this.alwaysSearchOnInitialLoad) {\n      this._updateSearchResults(searchParameters, {\n        replaceUrl: true\n      });\n    }\n  }\n\n  _setState(newState) {\n    const state = Object.assign(Object.assign({}, this.state), newState); // eslint-disable-next-line no-console\n\n    if (this.debug) console.log(\"Search UI: State Update\", newState, state);\n    this.state = state;\n    this.subscriptions.forEach(subscription => subscription(state));\n  }\n  /**\n   * Dynamically update the searchQuery configuration in this driver.\n   * This will issue a new query after being updated.\n   *\n   * @param Object searchQuery\n   */\n\n\n  setSearchQuery(searchQuery) {\n    this.searchQuery = searchQuery;\n\n    this._updateSearchResults({});\n  }\n  /**\n   * @param Object autocompleteQuery\n   */\n\n\n  setAutocompleteQuery(autocompleteQuery) {\n    this.autocompleteQuery = autocompleteQuery;\n  }\n  /**\n   * Any time state is updated in this Driver, the provided callback\n   * will be executed with the updated state.\n   *\n   * @param onStateChange Function\n   */\n\n\n  subscribeToStateChanges(onStateChange) {\n    this.subscriptions.push(onStateChange);\n  }\n  /**\n   * @param onStateChange Function\n   */\n\n\n  unsubscribeToStateChanges(onStateChange) {\n    this.subscriptions = this.subscriptions.filter(sub => sub !== onStateChange);\n  }\n  /**\n   * Remove all listeners\n   */\n\n\n  tearDown() {\n    this.subscriptions = [];\n    this.URLManager && this.URLManager.tearDown();\n  }\n  /**\n   * Retrieves all available actions\n   *\n   * @returns Object All actions\n   */\n\n\n  getActions() {\n    return this.actions;\n  }\n  /**\n   * Retrieve current state. Typically used on app initialization. Subsequent\n   * state updates should come through subscription.\n   *\n   * @returns Object Current state\n   */\n\n\n  getState() {\n    // We return a copy of state here, because we want to ensure the state\n    // inside of this object remains immutable.\n    return Object.assign({}, this.state);\n  }\n\n}\n\nexport default SearchDriver;","map":{"version":3,"sources":["/Users/mnaomi/Documents/TechGroupFinder/app/my-app/node_modules/@elastic/search-ui/lib/esm/SearchDriver.js"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","URLManager","RequestSequencer","DebounceManager","actions","Events","mergeFilters","INVALID_CREDENTIALS","a11y","filterSearchParameters","current","filters","resultsPerPage","searchTerm","sortDirection","sortField","sortList","DEFAULT_STATE","autocompletedResults","autocompletedResultsRequestId","autocompletedSuggestions","autocompletedSuggestionsRequestId","error","isLoading","facets","requestId","results","resultSearchTerm","totalPages","totalResults","pagingStart","pagingEnd","wasSearched","rawResponse","removeConditionalFacets","conditionalFacets","entries","reduce","acc","facetKey","facet","SearchDriver","constructor","apiConnector","autocompleteQuery","debug","initialState","onSearch","onAutocomplete","onResultClick","onAutocompleteResultClick","searchQuery","trackUrlState","urlPushDebounceLength","hasA11yNotifications","a11yNotificationMessages","alwaysSearchOnInitialLoad","state","_updateAutocomplete","autocompleteResults","autocompleteSuggestions","autocompleteRequestSequencer","next","queryConfig","assign","suggestions","events","autocomplete","then","autocompleted","isOldRequest","completed","_setState","_updateSearchResults","searchParameters","skipPushToUrl","replaceUrl","debounceManager","cancelByName","_makeSearchRequest","debounce","searchRequestSequencer","_a","restOfSearchQuery","requestState","search","resultState","start","end","messageArgs","a11yNotify","runWithDebounce","pushStateToURL","bind","message","actionName","action","console","warn","window","subscriptions","urlState","getStateFromURL","onURLStateChange","getLiveRegion","defaultMessages","startingState","newState","log","forEach","subscription","setSearchQuery","setAutocompleteQuery","subscribeToStateChanges","onStateChange","push","unsubscribeToStateChanges","filter","sub","tearDown","getActions","getState"],"mappings":"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","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport URLManager from \"./URLManager\";\nimport RequestSequencer from \"./RequestSequencer\";\nimport DebounceManager from \"./DebounceManager\";\nimport * as actions from \"./actions\";\nimport Events from \"./Events\";\nimport { mergeFilters } from \"./helpers\";\nimport { INVALID_CREDENTIALS } from \".\";\nimport * as a11y from \"./A11yNotifications\";\nfunction filterSearchParameters({ current, filters, resultsPerPage, searchTerm, sortDirection, sortField, sortList }) {\n    return {\n        current,\n        filters,\n        resultsPerPage,\n        searchTerm,\n        sortDirection,\n        sortField,\n        sortList\n    };\n}\nexport const DEFAULT_STATE = {\n    // Search Parameters -- This is state that represents the input state.\n    current: 1,\n    filters: [],\n    resultsPerPage: 20,\n    searchTerm: \"\",\n    sortDirection: \"\",\n    sortField: \"\",\n    sortList: [],\n    // Result State -- This state represents state that is updated automatically\n    // as the result of changing input state.\n    autocompletedResults: [],\n    autocompletedResultsRequestId: \"\",\n    autocompletedSuggestions: {},\n    autocompletedSuggestionsRequestId: \"\",\n    error: \"\",\n    isLoading: false,\n    facets: {},\n    requestId: \"\",\n    results: [],\n    resultSearchTerm: \"\",\n    totalPages: 0,\n    totalResults: 0,\n    pagingStart: 0,\n    pagingEnd: 0,\n    wasSearched: false,\n    rawResponse: {}\n};\nfunction removeConditionalFacets(facets = {}, conditionalFacets = {}, filters = []) {\n    return Object.entries(facets).reduce((acc, [facetKey, facet]) => {\n        if (conditionalFacets[facetKey] &&\n            typeof conditionalFacets[facetKey] === \"function\" &&\n            !conditionalFacets[facetKey]({ filters })) {\n            return acc;\n        }\n        acc[facetKey] = facet;\n        return acc;\n    }, {});\n}\n/*\n * The Driver is a framework agnostic search state manager that is capable\n * syncing state to the url.\n */\nclass SearchDriver {\n    constructor({ apiConnector, autocompleteQuery = {}, debug, initialState, onSearch, onAutocomplete, onResultClick, onAutocompleteResultClick, searchQuery = {}, trackUrlState = true, urlPushDebounceLength = 500, hasA11yNotifications = false, a11yNotificationMessages = {}, alwaysSearchOnInitialLoad = false }) {\n        this.state = DEFAULT_STATE;\n        /**\n         * This method is used to update state and trigger a new autocomplete search.\n         *\n         * @param {string} searchTerm\n         * @param {Object=} Object\n         * @param {boolean|Object} options.autocompleteResults - Should autocomplete results\n         * @param {boolean|Object} options.autocompleteSuggestions - Should autocomplete suggestions\n         */\n        this._updateAutocomplete = (searchTerm, \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        { autocompleteResults, autocompleteSuggestions } = {}) => {\n            const requestId = this.autocompleteRequestSequencer.next();\n            const queryConfig = Object.assign(Object.assign({}, (autocompleteResults && {\n                results: this.autocompleteQuery.results || {}\n            })), (autocompleteSuggestions && {\n                suggestions: this.autocompleteQuery.suggestions || {}\n            }));\n            return this.events\n                .autocomplete({ searchTerm }, queryConfig)\n                .then((autocompleted) => {\n                if (this.autocompleteRequestSequencer.isOldRequest(requestId))\n                    return;\n                this.autocompleteRequestSequencer.completed(requestId);\n                this._setState(autocompleted);\n            });\n        };\n        /**\n         * This method is used to update state and trigger a new search.\n         *\n         * @typedef {Object} RequestState\n         * @property {number} current\n         * @property {number} resultsPerPage\n         * @property {string} searchTerm\n         * @property {string} sortDirection\n         * @property {string} sortField\n         * @property {Array} sortList\n         *\n         * @param {RequestState} searchParameters - RequestState\n         * @param {Object=} Object\n         * @param {boolean} options.skipPushToUrl - Skip pushing the updated to the URL\n         * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n         * rather than 'push' to avoid adding a new history entry\n         */\n        this._updateSearchResults = (searchParameters, { skipPushToUrl = false, replaceUrl = false } = {}) => {\n            const { current, filters, resultsPerPage, searchTerm, sortDirection, sortField, sortList } = Object.assign(Object.assign({}, this.state), searchParameters);\n            // State updates should always be applied in the order that they are made. This function, _updateSearchResults,\n            // makes state updates.\n            // In the case where a call to \"_updateSearchResults\" was made and delayed for X amount of time using\n            // `debounceManager.runWithDebounce`, and a subsequent call is made _updateSearchResults before that delay ends, we\n            // want to make sure that outstanding call to \"_updateSearchResults\" is cancelled, as it would apply state updates\n            // out of order.\n            this.debounceManager.cancelByName(\"_updateSearchResults\");\n            this._setState({\n                current,\n                error: \"\",\n                filters,\n                resultsPerPage,\n                searchTerm,\n                sortDirection,\n                sortField,\n                sortList\n            });\n            this._makeSearchRequest({\n                skipPushToUrl,\n                replaceUrl\n            });\n        };\n        /**\n         * This method is separated out from _updateSearchResults so that it\n         * can be debounced.\n         *\n         * By debouncing our API calls, we can effectively allow action chaining.\n         *\n         * For Ex:\n         *\n         * If a user needs to make multiple filter updates at once, they could\n         * do so by calling an action 3 times in a row:\n         *\n         *   addFilter(\"states\", \"California\");\n         *   addFilter(\"states\", \"Nebraska\");\n         *   addFilter(\"states\", \"Pennsylvania\");\n         *\n         * We don't want to make 3 separate API calls like that in quick succession,\n         * so we debounce the API calls.\n         *\n         * Application state updates are performed in _updateSearchResults, but we\n         * wait to make the actual API calls until all actions have been called.\n         *\n         * @param {Object} options\n         * @param {boolean} options.skipPushToUrl - Skip pushing the updated to the URL\n         * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n         * rather than 'push' to avoid adding a new history entry\n         */\n        this._makeSearchRequest = DebounceManager.debounce(0, ({ skipPushToUrl, replaceUrl }) => {\n            const { current, filters, resultsPerPage, searchTerm, sortDirection, sortField, sortList } = this.state;\n            this._setState({\n                isLoading: true\n            });\n            const requestId = this.searchRequestSequencer.next();\n            const _a = this.searchQuery, { conditionalFacets } = _a, restOfSearchQuery = __rest(_a, [\"conditionalFacets\"]);\n            const queryConfig = Object.assign(Object.assign({}, restOfSearchQuery), { facets: removeConditionalFacets(this.searchQuery.facets, conditionalFacets, filters) });\n            const requestState = Object.assign(Object.assign({}, filterSearchParameters(this.state)), { filters: mergeFilters(filters, this.searchQuery.filters) });\n            return this.events.search(requestState, queryConfig).then((resultState) => {\n                if (this.searchRequestSequencer.isOldRequest(requestId))\n                    return;\n                this.searchRequestSequencer.completed(requestId);\n                // Results paging start & end\n                const { totalResults } = resultState;\n                const start = totalResults === 0 ? 0 : (current - 1) * resultsPerPage + 1;\n                const end = totalResults < start + resultsPerPage\n                    ? totalResults\n                    : start + resultsPerPage - 1;\n                this._setState(Object.assign(Object.assign({ isLoading: false, resultSearchTerm: searchTerm, pagingStart: start, pagingEnd: end }, resultState), { wasSearched: true }));\n                if (this.hasA11yNotifications) {\n                    const messageArgs = { start, end, totalResults, searchTerm };\n                    this.actions.a11yNotify(\"searchResults\", messageArgs);\n                }\n                if (!skipPushToUrl && this.trackUrlState) {\n                    // We debounce here so that we don't get a lot of intermediary\n                    // URL state if someone is updating a UI really fast, like typing\n                    // in a live search box for instance.\n                    this.debounceManager.runWithDebounce(this.urlPushDebounceLength, \"pushStateToURL\", this.URLManager.pushStateToURL.bind(this.URLManager), {\n                        current,\n                        filters,\n                        resultsPerPage,\n                        searchTerm,\n                        sortDirection,\n                        sortField,\n                        sortList\n                    }, { replaceUrl });\n                }\n            }, (error) => {\n                var _a;\n                if (error.message === INVALID_CREDENTIALS) {\n                    // The connector should have invalidated the credentials in its state by now\n                    // Getting the latest state from the connector\n                    this._setState(Object.assign({}, (((_a = this.apiConnector) === null || _a === void 0 ? void 0 : _a.state) && Object.assign({}, this.apiConnector.state))));\n                    // Stop execution of request\n                    // and let the consuming application handle the missing credentials\n                    return;\n                }\n                this._setState({\n                    error: `An unexpected error occurred: ${error.message}`\n                });\n            });\n        });\n        this.actions = Object.entries(actions).reduce((acc, [actionName, action]) => {\n            return Object.assign(Object.assign({}, acc), { [actionName]: action.bind(this) });\n        }, {});\n        this.actions = Object.assign(Object.assign({}, this.actions), ((apiConnector === null || apiConnector === void 0 ? void 0 : apiConnector.actions) && Object.assign({}, apiConnector.actions)));\n        Object.assign(this, this.actions);\n        this.events = new Events({\n            apiConnector,\n            onSearch,\n            onAutocomplete,\n            onResultClick,\n            onAutocompleteResultClick\n        });\n        this.debug = debug;\n        if (this.debug) {\n            console.warn(\"Search UI Debugging is enabled. This should be turned off in production deployments.\");\n            if (typeof window !== \"undefined\")\n                window[\"searchUI\"] = this;\n        }\n        this.autocompleteRequestSequencer = new RequestSequencer();\n        this.searchRequestSequencer = new RequestSequencer();\n        this.debounceManager = new DebounceManager();\n        this.autocompleteQuery = autocompleteQuery;\n        this.searchQuery = searchQuery;\n        this.subscriptions = [];\n        this.trackUrlState = trackUrlState;\n        this.urlPushDebounceLength = urlPushDebounceLength;\n        this.alwaysSearchOnInitialLoad = alwaysSearchOnInitialLoad;\n        this.apiConnector = apiConnector;\n        let urlState;\n        if (trackUrlState) {\n            this.URLManager = new URLManager();\n            urlState = this.URLManager.getStateFromURL();\n            this.URLManager.onURLStateChange((urlState) => {\n                this._updateSearchResults(Object.assign(Object.assign({}, DEFAULT_STATE), urlState), { skipPushToUrl: true });\n            });\n        }\n        else {\n            urlState = {};\n        }\n        // Manage screen reader accessible notifications\n        this.hasA11yNotifications = hasA11yNotifications;\n        if (this.hasA11yNotifications)\n            a11y.getLiveRegion();\n        this.a11yNotificationMessages = Object.assign(Object.assign({}, a11y.defaultMessages), a11yNotificationMessages);\n        // Remember the state this application is initialized into, so that we can\n        // reset to it later.\n        this.startingState = Object.assign(Object.assign({}, this.state), initialState);\n        // We filter these here to disallow anything other than valid search\n        // parameters to be passed in initial state, or url state. `results`, etc,\n        // should not be allowed to be passed in, that should be generated based on\n        // the results of the query\n        const searchParameters = filterSearchParameters(Object.assign(Object.assign({}, this.startingState), urlState));\n        // Initialize the state without calling _setState, because we don't\n        // want to trigger an update callback, we're just initializing the state\n        // to the correct default values for the initial UI render\n        this.state = Object.assign(Object.assign(Object.assign({}, this.state), ((apiConnector === null || apiConnector === void 0 ? void 0 : apiConnector.state) && Object.assign({}, apiConnector.state))), searchParameters);\n        // We'll trigger an initial search if initial parameters contain\n        // a search term or filters, or if alwaysSearchOnInitialLoad is set.\n        // Otherwise, we'll just save their selections in state as initial values.\n        if (searchParameters.searchTerm ||\n            searchParameters.filters.length > 0 ||\n            this.alwaysSearchOnInitialLoad) {\n            this._updateSearchResults(searchParameters, { replaceUrl: true });\n        }\n    }\n    _setState(newState) {\n        const state = Object.assign(Object.assign({}, this.state), newState);\n        // eslint-disable-next-line no-console\n        if (this.debug)\n            console.log(\"Search UI: State Update\", newState, state);\n        this.state = state;\n        this.subscriptions.forEach((subscription) => subscription(state));\n    }\n    /**\n     * Dynamically update the searchQuery configuration in this driver.\n     * This will issue a new query after being updated.\n     *\n     * @param Object searchQuery\n     */\n    setSearchQuery(searchQuery) {\n        this.searchQuery = searchQuery;\n        this._updateSearchResults({});\n    }\n    /**\n     * @param Object autocompleteQuery\n     */\n    setAutocompleteQuery(autocompleteQuery) {\n        this.autocompleteQuery = autocompleteQuery;\n    }\n    /**\n     * Any time state is updated in this Driver, the provided callback\n     * will be executed with the updated state.\n     *\n     * @param onStateChange Function\n     */\n    subscribeToStateChanges(onStateChange) {\n        this.subscriptions.push(onStateChange);\n    }\n    /**\n     * @param onStateChange Function\n     */\n    unsubscribeToStateChanges(onStateChange) {\n        this.subscriptions = this.subscriptions.filter((sub) => sub !== onStateChange);\n    }\n    /**\n     * Remove all listeners\n     */\n    tearDown() {\n        this.subscriptions = [];\n        this.URLManager && this.URLManager.tearDown();\n    }\n    /**\n     * Retrieves all available actions\n     *\n     * @returns Object All actions\n     */\n    getActions() {\n        return this.actions;\n    }\n    /**\n     * Retrieve current state. Typically used on app initialization. Subsequent\n     * state updates should come through subscription.\n     *\n     * @returns Object Current state\n     */\n    getState() {\n        // We return a copy of state here, because we want to ensure the state\n        // inside of this object remains immutable.\n        return Object.assign({}, this.state);\n    }\n}\nexport default SearchDriver;\n"]},"metadata":{},"sourceType":"module"}