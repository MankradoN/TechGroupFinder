{"ast":null,"code":"import React, { useState, useEffect } from \"react\";\nimport { SearchDriver } from \"@elastic/search-ui\";\nimport SearchContext from \"./SearchContext\";\nimport defaultA11yMessages from \"./A11yNotifications\";\n/**\n * The SearchProvider primarily holds a reference to the SearchDriver and\n * exposes it to the rest of the application in a Context.\n */\n\nconst SearchProvider = _ref => {\n  let {\n    children,\n    config,\n    driver\n  } = _ref;\n  const [driverInstance, setDriverInstance] = useState(null);\n  useEffect(() => {\n    // This initialization is done inside of useEffect, because initializing the SearchDriver server side\n    // will error out, since the driver depends on window. Placing the initialization inside of useEffect\n    // assures that it won't attempt to initialize server side.\n    const currentDriver = driver || new SearchDriver(Object.assign(Object.assign({}, config), {\n      a11yNotificationMessages: Object.assign(Object.assign({}, defaultA11yMessages), config.a11yNotificationMessages)\n    }));\n    setDriverInstance(currentDriver);\n    return () => {\n      currentDriver.tearDown();\n    };\n  }, []); // This effect allows users to dynamically update their searchQuery without re-mounting a SearchProvider,\n  // which would be destructive. An example of why this is useful is dynamically updating facets.\n\n  useEffect(() => {\n    if (driverInstance) {\n      driverInstance.setSearchQuery(config.searchQuery);\n    }\n  }, [config.searchQuery]);\n  useEffect(() => {\n    if (driverInstance) {\n      driverInstance.setAutocompleteQuery(config.autocompleteQuery);\n    }\n  }, [config.autocompleteQuery]); // Since driver is initialized in useEffect above, we are waiting\n  // to render until the driver is available.\n\n  if (!driverInstance) return null; // Passing the entire \"this.state\" to the Context is significant. Because\n  // Context determines when to re-render based on referential identity\n  // something like this could cause unnecessary renders:\n  //\n  // <SearchContext.Provider value={{driver: this.state.driver}}>\n  //\n  // By passing the entire state, we ensure that re-renders only occur when\n  // state is actually updated.\n\n  const contextValue = {\n    driver: driverInstance\n  };\n  return React.createElement(SearchContext.Provider, {\n    value: contextValue\n  }, children);\n};\n\nexport default SearchProvider;","map":{"version":3,"sources":["/Users/mnaomi/Documents/TechGroupFinder/app/node_modules/@elastic/react-search-ui/lib/esm/SearchProvider.js"],"names":["React","useState","useEffect","SearchDriver","SearchContext","defaultA11yMessages","SearchProvider","children","config","driver","driverInstance","setDriverInstance","currentDriver","Object","assign","a11yNotificationMessages","tearDown","setSearchQuery","searchQuery","setAutocompleteQuery","autocompleteQuery","contextValue","createElement","Provider","value"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C;AACA,SAASC,YAAT,QAA6B,oBAA7B;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,mBAAP,MAAgC,qBAAhC;AACA;AACA;AACA;AACA;;AACA,MAAMC,cAAc,GAAG,QAAkC;AAAA,MAAjC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,MAAZ;AAAoBC,IAAAA;AAApB,GAAiC;AACrD,QAAM,CAACC,cAAD,EAAiBC,iBAAjB,IAAsCV,QAAQ,CAAC,IAAD,CAApD;AACAC,EAAAA,SAAS,CAAC,MAAM;AACZ;AACA;AACA;AACA,UAAMU,aAAa,GAAGH,MAAM,IACxB,IAAIN,YAAJ,CAAiBU,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,MAAlB,CAAd,EAAyC;AAAEO,MAAAA,wBAAwB,EAAEF,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBT,mBAAlB,CAAd,EAAsDG,MAAM,CAACO,wBAA7D;AAA5B,KAAzC,CAAjB,CADJ;AAEAJ,IAAAA,iBAAiB,CAACC,aAAD,CAAjB;AACA,WAAO,MAAM;AACTA,MAAAA,aAAa,CAACI,QAAd;AACH,KAFD;AAGH,GAVQ,EAUN,EAVM,CAAT,CAFqD,CAarD;AACA;;AACAd,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAIQ,cAAJ,EAAoB;AAChBA,MAAAA,cAAc,CAACO,cAAf,CAA8BT,MAAM,CAACU,WAArC;AACH;AACJ,GAJQ,EAIN,CAACV,MAAM,CAACU,WAAR,CAJM,CAAT;AAKAhB,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAIQ,cAAJ,EAAoB;AAChBA,MAAAA,cAAc,CAACS,oBAAf,CAAoCX,MAAM,CAACY,iBAA3C;AACH;AACJ,GAJQ,EAIN,CAACZ,MAAM,CAACY,iBAAR,CAJM,CAAT,CApBqD,CAyBrD;AACA;;AACA,MAAI,CAACV,cAAL,EACI,OAAO,IAAP,CA5BiD,CA6BrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMW,YAAY,GAAG;AACjBZ,IAAAA,MAAM,EAAEC;AADS,GAArB;AAGA,SAAQV,KAAK,CAACsB,aAAN,CAAoBlB,aAAa,CAACmB,QAAlC,EAA4C;AAAEC,IAAAA,KAAK,EAAEH;AAAT,GAA5C,EAAqEd,QAArE,CAAR;AACH,CAzCD;;AA0CA,eAAeD,cAAf","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport { SearchDriver } from \"@elastic/search-ui\";\nimport SearchContext from \"./SearchContext\";\nimport defaultA11yMessages from \"./A11yNotifications\";\n/**\n * The SearchProvider primarily holds a reference to the SearchDriver and\n * exposes it to the rest of the application in a Context.\n */\nconst SearchProvider = ({ children, config, driver }) => {\n    const [driverInstance, setDriverInstance] = useState(null);\n    useEffect(() => {\n        // This initialization is done inside of useEffect, because initializing the SearchDriver server side\n        // will error out, since the driver depends on window. Placing the initialization inside of useEffect\n        // assures that it won't attempt to initialize server side.\n        const currentDriver = driver ||\n            new SearchDriver(Object.assign(Object.assign({}, config), { a11yNotificationMessages: Object.assign(Object.assign({}, defaultA11yMessages), config.a11yNotificationMessages) }));\n        setDriverInstance(currentDriver);\n        return () => {\n            currentDriver.tearDown();\n        };\n    }, []);\n    // This effect allows users to dynamically update their searchQuery without re-mounting a SearchProvider,\n    // which would be destructive. An example of why this is useful is dynamically updating facets.\n    useEffect(() => {\n        if (driverInstance) {\n            driverInstance.setSearchQuery(config.searchQuery);\n        }\n    }, [config.searchQuery]);\n    useEffect(() => {\n        if (driverInstance) {\n            driverInstance.setAutocompleteQuery(config.autocompleteQuery);\n        }\n    }, [config.autocompleteQuery]);\n    // Since driver is initialized in useEffect above, we are waiting\n    // to render until the driver is available.\n    if (!driverInstance)\n        return null;\n    // Passing the entire \"this.state\" to the Context is significant. Because\n    // Context determines when to re-render based on referential identity\n    // something like this could cause unnecessary renders:\n    //\n    // <SearchContext.Provider value={{driver: this.state.driver}}>\n    //\n    // By passing the entire state, we ensure that re-renders only occur when\n    // state is actually updated.\n    const contextValue = {\n        driver: driverInstance\n    };\n    return (React.createElement(SearchContext.Provider, { value: contextValue }, children));\n};\nexport default SearchProvider;\n"]},"metadata":{},"sourceType":"module"}