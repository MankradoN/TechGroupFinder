{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport deepEqual from \"deep-equal\";\n/**\n * Given a list of applied Filters, find FilterValues based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {*} filters\n * @param {*} name\n * @param {*} filterType\n */\n\nexport function findFilterValues(filters, name, filterType) {\n  const filter = filters.find(f => f.field === name && f.type === filterType);\n  if (!filter) return [];\n  return filter.values;\n}\n/**\n * Given a list of applied Filters, remove a single FilterValue based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {Filter[]} filters\n * @param {String} fieldName\n * @param {FilterValue} value\n * @param {FilterType} filterType\n */\n\nexport function removeSingleFilterValue(filters, fieldName, value, filterType) {\n  return filters.reduce((acc, filter) => {\n    const {\n      field,\n      values,\n      type\n    } = filter,\n          rest = __rest(filter, [\"field\", \"values\", \"type\"]);\n\n    if (field === fieldName && (!filterType || type === filterType)) {\n      const updatedFilterValues = values.filter(filterValue => !doFilterValuesMatch(filterValue, value));\n\n      if (updatedFilterValues.length > 0) {\n        return acc.concat(Object.assign({\n          field,\n          values: updatedFilterValues,\n          type\n        }, rest));\n      } else {\n        return acc;\n      }\n    }\n\n    return acc.concat(filter);\n  }, []);\n}\n/**\n * Given a Facet and a list of applied Filters, mark the Facet Values\n * for that Facet as \"selected\" based on \"fieldName\" and \"filterType\".\n *\n * @param {Facet} facet\n * @param {String} fieldName\n * @param {Filter[]} filters\n * @param {FilterType} filterType\n */\n\nexport function markSelectedFacetValuesFromFilters(facet, filters, fieldName, filterType) {\n  const facetValues = facet.data;\n  const filterValuesForField = findFilterValues(filters, fieldName, filterType) || [];\n  return Object.assign(Object.assign({}, facet), {\n    data: facetValues.map(facetValue => {\n      return Object.assign(Object.assign({}, facetValue), {\n        selected: filterValuesForField.some(filterValue => {\n          return doFilterValuesMatch(filterValue, facetValue.value);\n        })\n      });\n    })\n  });\n}\n/**\n * Useful for determining when filter values match. This could be used\n * when matching applied filters back to facet options, or for determining\n * whether or not a filter already exists in a list of applied filters.\n *\n * @param {FilterValue} filterValue1\n * @param {FilterValue} filterValue2\n */\n\nexport function doFilterValuesMatch(filterValue1, filterValue2) {\n  if (filterValue1 && filterValue1.name && filterValue2 && filterValue2.name && filterValue1.name === filterValue2.name) // If two filters have matching names, then they are the same filter, there\n    // is no need to do a more expensive deep equal comparison.\n    //\n    // This is also important because certain filters and facets will have\n    // differing values than their corresponding facet options. For instance,\n    // consider a time-based facet like \"Last 10 Minutes\". The value of the\n    // filter will be different depending on when it was selected, but the name\n    // will always match.\n    return true; // We use 'strict = true' to do a '===' of leaves, rather than '=='\n\n  return deepEqual(filterValue1, filterValue2, {\n    strict: true\n  });\n} // Mix unique filter type from one array into the other\n\nexport function mergeFilters(filters1, filters2) {\n  if (!filters2) return filters1;\n  return filters2.reduce((acc, next) => {\n    if (acc.find(f => f.type === next.type && f.field === next.field)) {\n      return acc;\n    }\n\n    return [...acc, next];\n  }, filters1);\n} // Check if filterValue is of type FilterValueRange\n// Using type predicates https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\n\nexport function isFilterValueRange(filterValue) {\n  return filterValue.name !== undefined;\n}","map":{"version":3,"sources":["/Users/mnaomi/Documents/TechGroupFinder/app/node_modules/@elastic/search-ui/lib/esm/helpers.js"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","deepEqual","findFilterValues","filters","name","filterType","filter","find","f","field","type","values","removeSingleFilterValue","fieldName","value","reduce","acc","rest","updatedFilterValues","filterValue","doFilterValuesMatch","concat","assign","markSelectedFacetValuesFromFilters","facet","facetValues","data","filterValuesForField","map","facetValue","selected","some","filterValue1","filterValue2","strict","mergeFilters","filters1","filters2","next","isFilterValueRange","undefined"],"mappings":"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","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport deepEqual from \"deep-equal\";\n/**\n * Given a list of applied Filters, find FilterValues based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {*} filters\n * @param {*} name\n * @param {*} filterType\n */\nexport function findFilterValues(filters, name, filterType) {\n    const filter = filters.find((f) => f.field === name && f.type === filterType);\n    if (!filter)\n        return [];\n    return filter.values;\n}\n/**\n * Given a list of applied Filters, remove a single FilterValue based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {Filter[]} filters\n * @param {String} fieldName\n * @param {FilterValue} value\n * @param {FilterType} filterType\n */\nexport function removeSingleFilterValue(filters, fieldName, value, filterType) {\n    return filters.reduce((acc, filter) => {\n        const { field, values, type } = filter, rest = __rest(filter, [\"field\", \"values\", \"type\"]);\n        if (field === fieldName && (!filterType || type === filterType)) {\n            const updatedFilterValues = values.filter((filterValue) => !doFilterValuesMatch(filterValue, value));\n            if (updatedFilterValues.length > 0) {\n                return acc.concat(Object.assign({ field, values: updatedFilterValues, type }, rest));\n            }\n            else {\n                return acc;\n            }\n        }\n        return acc.concat(filter);\n    }, []);\n}\n/**\n * Given a Facet and a list of applied Filters, mark the Facet Values\n * for that Facet as \"selected\" based on \"fieldName\" and \"filterType\".\n *\n * @param {Facet} facet\n * @param {String} fieldName\n * @param {Filter[]} filters\n * @param {FilterType} filterType\n */\nexport function markSelectedFacetValuesFromFilters(facet, filters, fieldName, filterType) {\n    const facetValues = facet.data;\n    const filterValuesForField = findFilterValues(filters, fieldName, filterType) || [];\n    return Object.assign(Object.assign({}, facet), { data: facetValues.map((facetValue) => {\n            return Object.assign(Object.assign({}, facetValue), { selected: filterValuesForField.some((filterValue) => {\n                    return doFilterValuesMatch(filterValue, facetValue.value);\n                }) });\n        }) });\n}\n/**\n * Useful for determining when filter values match. This could be used\n * when matching applied filters back to facet options, or for determining\n * whether or not a filter already exists in a list of applied filters.\n *\n * @param {FilterValue} filterValue1\n * @param {FilterValue} filterValue2\n */\nexport function doFilterValuesMatch(filterValue1, filterValue2) {\n    if (filterValue1 &&\n        filterValue1.name &&\n        filterValue2 &&\n        filterValue2.name &&\n        filterValue1.name === filterValue2.name)\n        // If two filters have matching names, then they are the same filter, there\n        // is no need to do a more expensive deep equal comparison.\n        //\n        // This is also important because certain filters and facets will have\n        // differing values than their corresponding facet options. For instance,\n        // consider a time-based facet like \"Last 10 Minutes\". The value of the\n        // filter will be different depending on when it was selected, but the name\n        // will always match.\n        return true;\n    // We use 'strict = true' to do a '===' of leaves, rather than '=='\n    return deepEqual(filterValue1, filterValue2, { strict: true });\n}\n// Mix unique filter type from one array into the other\nexport function mergeFilters(filters1, filters2) {\n    if (!filters2)\n        return filters1;\n    return filters2.reduce((acc, next) => {\n        if (acc.find((f) => f.type === next.type && f.field === next.field)) {\n            return acc;\n        }\n        return [...acc, next];\n    }, filters1);\n}\n// Check if filterValue is of type FilterValueRange\n// Using type predicates https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\nexport function isFilterValueRange(filterValue) {\n    return filterValue.name !== undefined;\n}\n"]},"metadata":{},"sourceType":"module"}