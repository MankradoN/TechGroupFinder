{"ast":null,"code":"import { createBrowserHistory as createHistory, createMemoryHistory } from \"history\";\nimport queryString from \"./queryString\";\n\nfunction isNumericString(num) {\n  return !isNaN(num);\n}\n\nfunction toSingleValue(val) {\n  return Array.isArray(val) ? val[val.length - 1] : val;\n}\n\nfunction toSingleValueInteger(num) {\n  return toInteger(toSingleValue(num));\n}\n\nfunction toInteger(num) {\n  if (!isNumericString(num)) return;\n  return parseInt(num, 10);\n}\n\nfunction parseFiltersFromQueryParams(queryParams) {\n  return queryParams.filters;\n}\n\nfunction parseCurrentFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.current);\n}\n\nfunction parseSearchTermFromQueryParams(queryParams) {\n  return toSingleValue(queryParams.q);\n}\n\nfunction parseOldSortFromQueryParams(queryParams) {\n  const sortField = toSingleValue(queryParams[\"sort-field\"]);\n  const sortDirection = toSingleValue(queryParams[\"sort-direction\"]);\n  if (sortField) return [sortField, sortDirection];\n  return [];\n}\n\nfunction parseSizeFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.size);\n}\n\nfunction parseSortFromQueryParams(queryParams) {\n  return queryParams[\"sort\"];\n}\n\nfunction paramsToState(queryParams) {\n  const state = {\n    current: parseCurrentFromQueryParams(queryParams),\n    filters: parseFiltersFromQueryParams(queryParams),\n    searchTerm: parseSearchTermFromQueryParams(queryParams),\n    resultsPerPage: parseSizeFromQueryParams(queryParams),\n    sortField: parseOldSortFromQueryParams(queryParams)[0],\n    sortDirection: parseOldSortFromQueryParams(queryParams)[1],\n    sortList: parseSortFromQueryParams(queryParams)\n  };\n  return Object.keys(state).reduce((acc, key) => {\n    const value = state[key];\n    if (value) acc[key] = value;\n    return acc;\n  }, {});\n}\n\nfunction stateToParams(_ref) {\n  let {\n    searchTerm,\n    current,\n    filters,\n    resultsPerPage,\n    sortDirection,\n    sortField,\n    sortList\n  } = _ref;\n  const params = {};\n  if (current > 1) params.current = current;\n  if (searchTerm) params.q = searchTerm;\n  if (resultsPerPage) params.size = resultsPerPage;\n\n  if (filters && filters.length > 0) {\n    params[\"filters\"] = filters;\n  }\n\n  if (sortList && sortList.length > 0) {\n    params[\"sort\"] = sortList;\n  } else if (sortField) {\n    params[\"sort-field\"] = sortField;\n    params[\"sort-direction\"] = sortDirection;\n  }\n\n  return params;\n}\n\nfunction stateToQueryString(state) {\n  return queryString.stringify(stateToParams(state));\n}\n/**\n * The URL Manager is responsible for synchronizing state between\n * SearchDriver and the URL. There are 3 main cases we handle when\n * synchronizing:\n *\n * 1. When the app loads, SearchDriver will need to\n * read the current state from the URL, in order to perform the search\n * expressed by the query string. `getStateFromURL` is used for this case.\n *\n * 2. When the URL changes as a result of `pushState` or `replaceState`,\n * SearchDriver will need to be notified and given the updated state, so that\n * it can re-run the current search. `onURLStateChange` is used for this case.\n *\n * 3. When state changes internally in the SearchDriver, as a result of an\n * Action, it will need to notify the URLManager of the change. `pushStateToURL`\n * is used for this case.\n */\n\n\nexport default class URLManager {\n  constructor() {\n    this.history = typeof window !== \"undefined\" ? createHistory() : createMemoryHistory();\n    this.lastPushSearchString = \"\";\n  }\n  /**\n   * Parse the current URL into application state\n   *\n   * @return {Object} - The parsed state object\n   */\n\n\n  getStateFromURL() {\n    const searchString = this.history ? this.history.location.search : \"\";\n    return paramsToState(queryString.parse(searchString));\n  }\n  /**\n   * Push the current state of the application to the URL\n   *\n   * @param {Object} state - The entire current state from the SearchDriver\n   * @param {boolean} options\n   * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n   * rather than 'push' to avoid adding a new history entry\n   */\n\n\n  pushStateToURL(state) {\n    let {\n      replaceUrl = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const searchString = stateToQueryString(state);\n    this.lastPushSearchString = searchString;\n    const navigationFunction = replaceUrl ? this.history.replace : this.history.push;\n    navigationFunction({\n      search: `?${searchString}`\n    });\n  }\n  /**\n   * Add an event handler to be executed whenever state is pushed to the URL\n   *\n   * @callback requestCallback\n   * @param {Object} state - Updated application state parsed from the new URL\n   *\n   * @param {requestCallback} callback\n   */\n\n\n  onURLStateChange(callback) {\n    this.unlisten = this.history.listen(location => {\n      // If this URL is updated as a result of a pushState request, we don't\n      // want to notify that the URL changed.\n      if (`?${this.lastPushSearchString}` === location.search) return; // Once we've decided to return based on lastPushSearchString, reset\n      // it so that we don't break back / forward button.\n\n      this.lastPushSearchString = \"\";\n      callback(paramsToState(queryString.parse(location.search)));\n    });\n  }\n\n  tearDown() {\n    this.unlisten();\n  }\n\n}","map":{"version":3,"sources":["/Users/mnaomi/Documents/TechGroupFinder/app/my-app/node_modules/@elastic/search-ui/lib/esm/URLManager.js"],"names":["createBrowserHistory","createHistory","createMemoryHistory","queryString","isNumericString","num","isNaN","toSingleValue","val","Array","isArray","length","toSingleValueInteger","toInteger","parseInt","parseFiltersFromQueryParams","queryParams","filters","parseCurrentFromQueryParams","current","parseSearchTermFromQueryParams","q","parseOldSortFromQueryParams","sortField","sortDirection","parseSizeFromQueryParams","size","parseSortFromQueryParams","paramsToState","state","searchTerm","resultsPerPage","sortList","Object","keys","reduce","acc","key","value","stateToParams","params","stateToQueryString","stringify","URLManager","constructor","history","window","lastPushSearchString","getStateFromURL","searchString","location","search","parse","pushStateToURL","replaceUrl","navigationFunction","replace","push","onURLStateChange","callback","unlisten","listen","tearDown"],"mappings":"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","sourcesContent":["import { createBrowserHistory as createHistory, createMemoryHistory } from \"history\";\nimport queryString from \"./queryString\";\nfunction isNumericString(num) {\n    return !isNaN(num);\n}\nfunction toSingleValue(val) {\n    return Array.isArray(val) ? val[val.length - 1] : val;\n}\nfunction toSingleValueInteger(num) {\n    return toInteger(toSingleValue(num));\n}\nfunction toInteger(num) {\n    if (!isNumericString(num))\n        return;\n    return parseInt(num, 10);\n}\nfunction parseFiltersFromQueryParams(queryParams) {\n    return queryParams.filters;\n}\nfunction parseCurrentFromQueryParams(queryParams) {\n    return toSingleValueInteger(queryParams.current);\n}\nfunction parseSearchTermFromQueryParams(queryParams) {\n    return toSingleValue(queryParams.q);\n}\nfunction parseOldSortFromQueryParams(queryParams) {\n    const sortField = toSingleValue(queryParams[\"sort-field\"]);\n    const sortDirection = toSingleValue(queryParams[\"sort-direction\"]);\n    if (sortField)\n        return [sortField, sortDirection];\n    return [];\n}\nfunction parseSizeFromQueryParams(queryParams) {\n    return toSingleValueInteger(queryParams.size);\n}\nfunction parseSortFromQueryParams(queryParams) {\n    return queryParams[\"sort\"];\n}\nfunction paramsToState(queryParams) {\n    const state = {\n        current: parseCurrentFromQueryParams(queryParams),\n        filters: parseFiltersFromQueryParams(queryParams),\n        searchTerm: parseSearchTermFromQueryParams(queryParams),\n        resultsPerPage: parseSizeFromQueryParams(queryParams),\n        sortField: parseOldSortFromQueryParams(queryParams)[0],\n        sortDirection: parseOldSortFromQueryParams(queryParams)[1],\n        sortList: parseSortFromQueryParams(queryParams)\n    };\n    return Object.keys(state).reduce((acc, key) => {\n        const value = state[key];\n        if (value)\n            acc[key] = value;\n        return acc;\n    }, {});\n}\nfunction stateToParams({ searchTerm, current, filters, resultsPerPage, sortDirection, sortField, sortList }) {\n    const params = {};\n    if (current > 1)\n        params.current = current;\n    if (searchTerm)\n        params.q = searchTerm;\n    if (resultsPerPage)\n        params.size = resultsPerPage;\n    if (filters && filters.length > 0) {\n        params[\"filters\"] = filters;\n    }\n    if (sortList && sortList.length > 0) {\n        params[\"sort\"] = sortList;\n    }\n    else if (sortField) {\n        params[\"sort-field\"] = sortField;\n        params[\"sort-direction\"] = sortDirection;\n    }\n    return params;\n}\nfunction stateToQueryString(state) {\n    return queryString.stringify(stateToParams(state));\n}\n/**\n * The URL Manager is responsible for synchronizing state between\n * SearchDriver and the URL. There are 3 main cases we handle when\n * synchronizing:\n *\n * 1. When the app loads, SearchDriver will need to\n * read the current state from the URL, in order to perform the search\n * expressed by the query string. `getStateFromURL` is used for this case.\n *\n * 2. When the URL changes as a result of `pushState` or `replaceState`,\n * SearchDriver will need to be notified and given the updated state, so that\n * it can re-run the current search. `onURLStateChange` is used for this case.\n *\n * 3. When state changes internally in the SearchDriver, as a result of an\n * Action, it will need to notify the URLManager of the change. `pushStateToURL`\n * is used for this case.\n */\nexport default class URLManager {\n    constructor() {\n        this.history =\n            typeof window !== \"undefined\" ? createHistory() : createMemoryHistory();\n        this.lastPushSearchString = \"\";\n    }\n    /**\n     * Parse the current URL into application state\n     *\n     * @return {Object} - The parsed state object\n     */\n    getStateFromURL() {\n        const searchString = this.history ? this.history.location.search : \"\";\n        return paramsToState(queryString.parse(searchString));\n    }\n    /**\n     * Push the current state of the application to the URL\n     *\n     * @param {Object} state - The entire current state from the SearchDriver\n     * @param {boolean} options\n     * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n     * rather than 'push' to avoid adding a new history entry\n     */\n    pushStateToURL(state, { replaceUrl = false } = {}) {\n        const searchString = stateToQueryString(state);\n        this.lastPushSearchString = searchString;\n        const navigationFunction = replaceUrl\n            ? this.history.replace\n            : this.history.push;\n        navigationFunction({\n            search: `?${searchString}`\n        });\n    }\n    /**\n     * Add an event handler to be executed whenever state is pushed to the URL\n     *\n     * @callback requestCallback\n     * @param {Object} state - Updated application state parsed from the new URL\n     *\n     * @param {requestCallback} callback\n     */\n    onURLStateChange(callback) {\n        this.unlisten = this.history.listen((location) => {\n            // If this URL is updated as a result of a pushState request, we don't\n            // want to notify that the URL changed.\n            if (`?${this.lastPushSearchString}` === location.search)\n                return;\n            // Once we've decided to return based on lastPushSearchString, reset\n            // it so that we don't break back / forward button.\n            this.lastPushSearchString = \"\";\n            callback(paramsToState(queryString.parse(location.search)));\n        });\n    }\n    tearDown() {\n        this.unlisten();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}