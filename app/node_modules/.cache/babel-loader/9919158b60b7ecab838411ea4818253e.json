{"ast":null,"code":"function isFieldValueWrapper(object) {\n  return object && (Object.prototype.hasOwnProperty.call(object, \"raw\") || Object.prototype.hasOwnProperty.call(object, \"snippet\"));\n} // Returns true for objects like this:\n// objectField: {\n//     objectSubField1: { raw: \"one\" },\n//     objectSubField2: { raw: \"two\" }\n// }\n// And false for objects like this:\n// objectField: { raw: \"one\" }\n\n\nfunction isNestedField(result, field) {\n  return result && result[field] && field !== \"_meta\" && typeof result[field] === \"object\" && !isFieldValueWrapper(result[field]);\n} // Takes any value and removes the wrapper around deepest values\n// (removes the wrapper Object with \"raw\" and/or \"snippet\" fields)\n// See tests for examples\n\n\nfunction cleanValueWrappers(value) {\n  if (isFieldValueWrapper(value)) {\n    return getEscapedField(value);\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(cleanValueWrappers);\n  }\n\n  if (typeof value === \"object\") {\n    return Object.entries(value).reduce((acc, _ref) => {\n      let [key, value] = _ref;\n      acc[key] = cleanValueWrappers(value);\n      return acc;\n    }, {});\n  }\n\n  return value;\n}\n\nfunction getFieldType(object, type) {\n  if (object) return object[type];\n}\n\nexport function getRaw(object) {\n  return getFieldType(object, \"raw\");\n}\n\nfunction getSnippet(object) {\n  return getFieldType(object, \"snippet\");\n}\n\nfunction htmlEscape(str) {\n  if (!str) return \"\";\n  return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\n\nexport function getEscapedField(maybeObject) {\n  // Fallback to raw values here, because non-string fields\n  // will not have a snippet fallback. Raw values MUST be html escaped.\n  const safeField = getSnippet(maybeObject) || htmlEscape(getRaw(maybeObject));\n  return Array.isArray(safeField) ? safeField.join(\", \") : safeField;\n}\nexport function formatResult(result) {\n  return Object.keys(result).reduce((acc, field) => {\n    if (isNestedField(result, field)) {\n      return Object.assign(Object.assign({}, acc), {\n        [field]: JSON.stringify(cleanValueWrappers(result[field]))\n      });\n    } // If we receive an arbitrary value from the response, we may not properly\n    // handle it, so we should filter out arbitrary values here.\n    //\n    // I.e.,\n    // Arbitrary value: \"_metaField: '1939191'\"\n    // vs.\n    // FieldValueWrapper: \"_metaField: {raw: '1939191'}\"\n\n\n    if (!isFieldValueWrapper(result[field])) return acc;\n    return Object.assign(Object.assign({}, acc), {\n      [field]: getEscapedField(result[field])\n    });\n  }, {});\n}","map":{"version":3,"sources":["/Users/mnaomi/Documents/TechGroupFinder/app/my-app/node_modules/@elastic/react-search-ui-views/lib/esm/view-helpers/formatResult.js"],"names":["isFieldValueWrapper","object","Object","prototype","hasOwnProperty","call","isNestedField","result","field","cleanValueWrappers","value","getEscapedField","Array","isArray","map","entries","reduce","acc","key","getFieldType","type","getRaw","getSnippet","htmlEscape","str","String","replace","maybeObject","safeField","join","formatResult","keys","assign","JSON","stringify"],"mappings":"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","sourcesContent":["function isFieldValueWrapper(object) {\n    return (object &&\n        (Object.prototype.hasOwnProperty.call(object, \"raw\") ||\n            Object.prototype.hasOwnProperty.call(object, \"snippet\")));\n}\n// Returns true for objects like this:\n// objectField: {\n//     objectSubField1: { raw: \"one\" },\n//     objectSubField2: { raw: \"two\" }\n// }\n// And false for objects like this:\n// objectField: { raw: \"one\" }\nfunction isNestedField(result, field) {\n    return (result &&\n        result[field] &&\n        field !== \"_meta\" &&\n        typeof result[field] === \"object\" &&\n        !isFieldValueWrapper(result[field]));\n}\n// Takes any value and removes the wrapper around deepest values\n// (removes the wrapper Object with \"raw\" and/or \"snippet\" fields)\n// See tests for examples\nfunction cleanValueWrappers(value) {\n    if (isFieldValueWrapper(value)) {\n        return getEscapedField(value);\n    }\n    if (Array.isArray(value)) {\n        return value.map(cleanValueWrappers);\n    }\n    if (typeof value === \"object\") {\n        return Object.entries(value).reduce((acc, [key, value]) => {\n            acc[key] = cleanValueWrappers(value);\n            return acc;\n        }, {});\n    }\n    return value;\n}\nfunction getFieldType(object, type) {\n    if (object)\n        return object[type];\n}\nexport function getRaw(object) {\n    return getFieldType(object, \"raw\");\n}\nfunction getSnippet(object) {\n    return getFieldType(object, \"snippet\");\n}\nfunction htmlEscape(str) {\n    if (!str)\n        return \"\";\n    return String(str)\n        .replace(/&/g, \"&amp;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#39;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\");\n}\nexport function getEscapedField(maybeObject) {\n    // Fallback to raw values here, because non-string fields\n    // will not have a snippet fallback. Raw values MUST be html escaped.\n    const safeField = getSnippet(maybeObject) || htmlEscape(getRaw(maybeObject));\n    return Array.isArray(safeField) ? safeField.join(\", \") : safeField;\n}\nexport function formatResult(result) {\n    return Object.keys(result).reduce((acc, field) => {\n        if (isNestedField(result, field)) {\n            return Object.assign(Object.assign({}, acc), { [field]: JSON.stringify(cleanValueWrappers(result[field])) });\n        }\n        // If we receive an arbitrary value from the response, we may not properly\n        // handle it, so we should filter out arbitrary values here.\n        //\n        // I.e.,\n        // Arbitrary value: \"_metaField: '1939191'\"\n        // vs.\n        // FieldValueWrapper: \"_metaField: {raw: '1939191'}\"\n        if (!isFieldValueWrapper(result[field]))\n            return acc;\n        return Object.assign(Object.assign({}, acc), { [field]: getEscapedField(result[field]) });\n    }, {});\n}\n"]},"metadata":{},"sourceType":"module"}